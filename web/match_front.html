<!-- made by sara chiriboga
     discord: sarilolaaa -->
     
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <style>
    body { font-family: Arial, Helvetica, sans-serif; font-size: 25px; }
    #card-question { text-align: center; font-size: 27px; margin-bottom: 30px; }
    .concept { font-size: 25px; border-radius: 3px; width: 100px; max-width: 300px; transition: background-color 0.3s; }
    #cont { display: flex; justify-content: space-around; flex-direction: column; gap: 20px; width: fit-content; margin: 0 auto; }
    .concept-pair { display: flex; flex-direction: row; gap: 10px; align-items: center; justify-content: center; }
    .definition { width: 400px; max-width: 900px; word-wrap: break-word; margin-left: 100px; }
    .correct-answer { background-color: #75f894 !important; border: 2px solid #28a745 !important; }
    .incorrect-answer { background-color: #f1626e !important; border: 2px solid #dc3545 !important; }
    .answer-shown .concept { pointer-events: none; }
  </style>
</head>
<body>

<h1 id="card-question">{{Question or Instructions}}</h1>
<div id="cont"></div>
<script>
  // --- Persistence library for saving state between card front/back (from SimonLammer/anki-persistence) ---
  // Provides a cross-platform way to store data in sessionStorage or window objects for Anki cards
  if(void 0===window.Persistence){var e="github.com/SimonLammer/anki-persistence/",t="_default";if(window.Persistence_sessionStorage=function(){var i=!1;try{"object"==typeof window.sessionStorage&&(i=!0,this.clear=function(){for(var t=0;t<sessionStorage.length;t++){var i=sessionStorage.key(t);0==i.indexOf(e)&&(sessionStorage.removeItem(i),t--)}},this.setItem=function(i,n){void 0==n&&(n=i,i=t),sessionStorage.setItem(e+i,JSON.stringify(n))},this.getItem=function(i){return void 0==i&&(i=t),JSON.parse(sessionStorage.getItem(e+i))},this.removeItem=function(i){void 0==i&&(i=t),sessionStorage.removeItem(e+i)},this.getAllKeys=function(){for(var t=[],i=Object.keys(sessionStorage),n=0;n<i.length;n++){var s=i[n];0==s.indexOf(e)&&t.push(s.substring(e.length,s.length))}return t.sort()})}catch(n){}this.isAvailable=function(){return i}},window.Persistence_windowKey=function(i){var n=window[i],s=!1;"object"==typeof n&&(s=!0,this.clear=function(){n[e]={}},this.setItem=function(i,s){void 0==s&&(s=i,i=t),n[e][i]=s},this.getItem=function(i){return void 0==i&&(i=t),void 0==n[e][i]?null:n[e][i]},this.removeItem=function(i){void 0==i&&(i=t),delete n[e][i]},this.getAllKeys=function(){return Object.keys(n[e])},void 0==n[e]&&this.clear()),this.isAvailable=function(){return s}},window.Persistence=new Persistence_sessionStorage,Persistence.isAvailable()||(window.Persistence=new Persistence_windowKey("py")),!Persistence.isAvailable()){var i=window.location.toString().indexOf("title"),n=window.location.toString().indexOf("main",i);i>0&&n>0&&n-i<10&&(window.Persistence=new Persistence_windowKey("qt"))}}
</script>
<script>
// --- Utility: Checks if a string is an Anki placeholder (e.g., {{Field}}) ---
function isAnkiPlaceholder(text) {
  return typeof text === 'string' && text.startsWith('\x7B') && text.endsWith('\x7D\x7D');
}

// --- Utility: Fisher-Yates shuffle for randomizing arrays ---
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

// --- Save data to persistence (for use between front/back of card) ---
function saveData(key, value) {
  if (window.Persistence && typeof window.Persistence.setItem === "function") {
    window.Persistence.setItem(key, value);
  }
}

// --- Load data from persistence, with fallback ---
function loadData(key, fallback) {
  if (window.Persistence && typeof window.Persistence.getItem === "function") {
    const result = window.Persistence.getItem(key);
    return result !== null ? result : fallback;
  }
  return fallback;
}

// --- Main logic: initialize the matching card front ---
(function initFront() {
  try {
    // Get field values for definitions and concepts (from Anki template)
    const definitionFields = [
      "{{Answer 1}}", "{{Answer 2}}", "{{Answer 3}}", "{{Answer 4}}"
    ];
    const conceptFields = [
      "{{Concept 1}}", "{{Concept 2}}", "{{Concept 3}}", "{{Concept 4}}"
    ];

    // Remove empty/placeholder fields and keep original index for answer checking
    const validDefinitions = definitionFields.map((text, idx) => ({ text: text.trim().replace(/^\d+\.\s*/, ''), idx }))
      .filter(obj => obj.text && !isAnkiPlaceholder(obj.text));
    const validConcepts = conceptFields.map((text, idx) => ({ text: text.trim(), idx }))
      .filter(obj => obj.text && !isAnkiPlaceholder(obj.text));

    // Only use as many pairs as both sides have
    const answerCount = Math.min(validDefinitions.length, validConcepts.length);

    // --- Shuffle definitions for matching ---
    let shuffledDefinitions = validDefinitions.slice(0, answerCount); // array with original index
    shuffleArray(shuffledDefinitions);

    // Save the shuffled mapping for use on the back of the card
    saveData("shuffledDefinitions", shuffledDefinitions);

    // --- Initialize all selects to default (no selection) and save ---
    let savedSelections = Array(answerCount).fill("");
    saveData("selections", savedSelections);

    // --- Build the UI: one row per concept/definition pair ---
    const cont = document.getElementById('cont');
    cont.innerHTML = "";

    for (let i = 0; i < answerCount; i++) {
      const defText = shuffledDefinitions[i]?.text ?? '';
      const conceptLabel = validConcepts[i]?.text ?? '';

      // Row container
      const pairDiv = document.createElement('div');
      pairDiv.className = 'concept-pair';

      // Concept label
      const label = document.createElement('label');
      label.textContent = conceptLabel;
      label.setAttribute('for', `concept${i+1}`);

      // Dropdown for selecting answer
      const select = document.createElement('select');
      select.className = 'concept';
      select.id = `concept${i+1}`;
      select.innerHTML = '<option value="">Select</option>';
      for(let j = 1; j <= answerCount; j++) {
        const opt = document.createElement('option');
        opt.value = j;
        opt.textContent = j;
        select.appendChild(opt);
      }
      if (savedSelections[i]) select.value = savedSelections[i];

      // Save selection changes to persistence
      select.addEventListener('change', () => {
        const selects = document.querySelectorAll('.concept');
        const newSelections = Array.from(selects).map(s => s.value);
        saveData("selections", newSelections);
      });

      // Definition text
      const defDiv = document.createElement('div');
      defDiv.className = 'definition';
      defDiv.textContent = `${i+1}. ${defText}`;

      // Assemble row
      pairDiv.appendChild(label);
      pairDiv.appendChild(select);
      pairDiv.appendChild(defDiv);
      cont.appendChild(pairDiv);
    }

    // --- Expose hooks for Anki to show/hide answers ---
    window.onShowAnswer = () => {
      document.getElementById('cont').classList.add('answer-shown');
    };
    window.onUpdate = () => {
      document.getElementById('cont').classList.remove('answer-shown');
    };

  } catch (error) {
    // Show error in card if something fails
    console.error('Error:', error);
    const errorDiv = document.createElement('div');
    errorDiv.style.color = 'red';
    errorDiv.textContent = 'Error loading card';
    document.getElementById('card-question').after(errorDiv);
  }
})();
</script>
</body>
</html>